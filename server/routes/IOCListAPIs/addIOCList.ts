import Crypto from 'crypto';
import { CoreSetup, KibanaRequest, RequestHandlerContext } from 'kibana/server';
import { IOCList } from '../../../common/types';
import { AuthenticatedUser } from 'x-pack/plugins/security/public';
import { ApiResponse } from '@elastic/elasticsearch';
import { Context } from '@elastic/elasticsearch/lib/Transport';
import { RequestParams } from '@elastic/elasticsearch';

export async function handleNewIOCList(
  context: RequestHandlerContext,
  request: KibanaRequest,
  core: CoreSetup
) {
  const hasher = Crypto.createHash('sha1');
  const newIOCList: IOCList = request.body as IOCList;
  const userauth: AuthenticatedUser = core.http.auth.get(request).state as AuthenticatedUser;
  var retVal: boolean | ApiResponse<Record<string, any>, Context> = false;

  //because we change the way the list are layout (from an object with nested fields to a json string) we no longer need to parse the list in this manner
  //parse out the list

  var searchparams: RequestParams.Search = {
    //checking to see if the list name already exist again
    index: 'ioc-list',
    body: {
      query: {
        bool: {
          must: [{ match: { 'listName.keyword': newIOCList.listName } }],
        },
      },
    },
  };

  var response;

  var checkStatus;
  await context.core.elasticsearch.client.asCurrentUser.search(searchparams).then((res) => {
    response = res;
    if (res.body.hits.hits.length > 0) {
      //if there is a hit we return true
      checkStatus = true;
    } else {
      //if there isnt a hit
      checkStatus = false;
    }
  });

  if (checkStatus) {
    //if the list exist return an error of 401
    return {
      body: {
        status: 401,
      },
    };
  }
  if (newIOCList.username != null) {
    hasher.update(JSON.stringify(newIOCList));

    let newArray: {
      fieldName: string | number;
      fieldValue: string | number;
      flag: string | number;
      note: string | number;
      rowCount: string | number;
    }[] = [];
    JSON.parse(newIOCList.IOCList).forEach((e) => {
      newArray.push({ fieldName: e[0], fieldValue: e[1], flag: e[2], note: e[3], rowCount: e[4] });
    });

    var createParams = {
      id: hasher.digest('hex'),
      index: 'ioc-list',
      body: {
        username: userauth.username,
        IOCList: JSON.stringify(newArray),
        listName: newIOCList.listName,
        creationDate: newIOCList.creationDate,
        updateDate: newIOCList.updateDate,
        hasUpdated: newIOCList.hasUpdated,
        additionalUsers: newIOCList.additionalUsers,
        description: newIOCList.description,
        autoGenerated: false,
        listSource: newIOCList.listSource,
      },
    };
    var status: any = 200;
    let error: any = {};
    await context.core.elasticsearch.client.asCurrentUser
      .create(createParams)
      .then((res: any) => {
        if (res.error.meta.body.hasOwnProperty('error')) {
          // console.log('TRY__________________________________________');
          status = 400;
        } else {
          retVal = res;
          status = 200;
          // createerr = { statusCode: 200, errorMessage: '', errorValue: '' };
        }
      })
      .catch((err) => {
        // console.log(JSON.stringify(err));
        // console.log('CATCH__________________________________________________');
        if (err.hasOwnProperty('meta')) {
          // console.log('ERROR--------------------');
          error = err;
          status = 400;
        } else {
          error = err;
          status = 200;
        }
      });
    return {
      body: {
        time: new Date().toISOString(),
        successful: retVal,
        status: status,
        error: error,
      },
    };
  }
}
